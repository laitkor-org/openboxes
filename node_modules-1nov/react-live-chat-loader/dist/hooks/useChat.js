"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

var _context = require("../context");

var Providers = _interopRequireWildcard(require("../providers"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const requestIdleCallback = typeof window !== 'undefined' ? window.requestIdleCallback : null;
const connection = typeof window !== 'undefined' ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
window.navigator && window.navigator.connection : null;
let scriptLoaded = false;

const useChat = ({
  loadWhenIdle
} = {
  loadWhenIdle: false
}) => {
  const {
    provider,
    providerKey,
    idlePeriod,
    state,
    setState,
    appID,
    locale
  } = (0, _react.useContext)(_context.LiveChatLoaderContext);
  (0, _react.useEffect)(() => {
    // Don't load if idlePeriod is 0, null or undefined
    if (typeof window === 'undefined' || !loadWhenIdle || !idlePeriod) return; // Don't load if 2g connection or save-data is enabled

    if (connection && (connection.saveData || /2g/.test(connection.effectiveType))) return;
    if (isNaN(idlePeriod)) return; // deadline.timeRemaining() has an upper limit of 50 milliseconds
    // We want to ensure the page has been idle for a significant period of time
    // Therefore we count consecutive maximum timeRemaining counts and load chat when we reach our threshold

    let elapsedIdlePeriod = 0;
    let previousTimeRemaining = 0;

    const scheduleLoadChat = deadline => {
      if (elapsedIdlePeriod > idlePeriod) return loadChat({
        open: false
      });
      const timeRemaining = deadline.timeRemaining(); // To ensure browser is idle, only accumalte elapsedIdlePeriod when
      // two consecutive maximum timeRemaining's have been observed

      if (previousTimeRemaining > 49 && timeRemaining > 49) elapsedIdlePeriod += timeRemaining;
      previousTimeRemaining = timeRemaining;
      requestIdleCallback === null || requestIdleCallback === void 0 ? void 0 : requestIdleCallback(scheduleLoadChat);
    };

    if (requestIdleCallback) {
      requestIdleCallback(scheduleLoadChat);
    } else {
      setTimeout(() => loadChat({
        open: false
      }), idlePeriod);
    }
  }, []);
  const chatProvider = Providers[provider];
  const loadChat = (0, _react.useCallback)(({
    open = true
  }) => {
    if (!providerKey) {
      //eslint-disable-next-line no-console
      console.error('No api key given to react-live-chat-loader');
      return;
    }

    if (!provider) {
      //eslint-disable-next-line no-console
      console.error('No provider given to react-live-chat-loader');
      return;
    }

    if (state === 'opening') return;
    if (state === 'open') return chatProvider.close();
    if (state === 'complete') return chatProvider.open();

    if (!scriptLoaded) {
      scriptLoaded = true;
      chatProvider.load({
        providerKey,
        setState,
        appID,
        locale
      });
    }

    if (open) {
      setState('opening');
      chatProvider.open();
      setState('open');
    }
  }, []);
  return [state, loadChat];
};

var _default = useChat;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ob29rcy91c2VDaGF0LnRzIl0sIm5hbWVzIjpbInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJ3aW5kb3ciLCJjb25uZWN0aW9uIiwibmF2aWdhdG9yIiwic2NyaXB0TG9hZGVkIiwidXNlQ2hhdCIsImxvYWRXaGVuSWRsZSIsInByb3ZpZGVyIiwicHJvdmlkZXJLZXkiLCJpZGxlUGVyaW9kIiwic3RhdGUiLCJzZXRTdGF0ZSIsImFwcElEIiwibG9jYWxlIiwiTGl2ZUNoYXRMb2FkZXJDb250ZXh0Iiwic2F2ZURhdGEiLCJ0ZXN0IiwiZWZmZWN0aXZlVHlwZSIsImlzTmFOIiwiZWxhcHNlZElkbGVQZXJpb2QiLCJwcmV2aW91c1RpbWVSZW1haW5pbmciLCJzY2hlZHVsZUxvYWRDaGF0IiwiZGVhZGxpbmUiLCJsb2FkQ2hhdCIsIm9wZW4iLCJ0aW1lUmVtYWluaW5nIiwic2V0VGltZW91dCIsImNoYXRQcm92aWRlciIsIlByb3ZpZGVycyIsImNvbnNvbGUiLCJlcnJvciIsImNsb3NlIiwibG9hZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBOztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxtQkFBbUIsR0FDdkIsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBTSxDQUFDRCxtQkFBdkMsR0FBNkQsSUFEL0Q7QUFFQSxNQUFNRSxVQUFVLEdBQ2QsT0FBT0QsTUFBUCxLQUFrQixXQUFsQixHQUNJO0FBQ0FBLE1BQU0sQ0FBQ0UsU0FBUCxJQUFxQkYsTUFBTSxDQUFDRSxTQUFSLENBQTBCRCxVQUZsRCxHQUdJLElBSk47QUFNQSxJQUFJRSxZQUFZLEdBQUcsS0FBbkI7O0FBRUEsTUFBTUMsT0FBTyxHQUFHLENBQ2Q7QUFDRUMsRUFBQUE7QUFERixJQUlJO0FBQUVBLEVBQUFBLFlBQVksRUFBRTtBQUFoQixDQUxVLEtBTXFDO0FBQ25ELFFBQU07QUFDSkMsSUFBQUEsUUFESTtBQUVKQyxJQUFBQSxXQUZJO0FBR0pDLElBQUFBLFVBSEk7QUFJSkMsSUFBQUEsS0FKSTtBQUtKQyxJQUFBQSxRQUxJO0FBTUpDLElBQUFBLEtBTkk7QUFPSkMsSUFBQUE7QUFQSSxNQVFGLHVCQUFXQyw4QkFBWCxDQVJKO0FBVUEsd0JBQVUsTUFBTTtBQUNkO0FBQ0EsUUFBSSxPQUFPYixNQUFQLEtBQWtCLFdBQWxCLElBQWlDLENBQUNLLFlBQWxDLElBQWtELENBQUNHLFVBQXZELEVBQW1FLE9BRnJELENBSWQ7O0FBQ0EsUUFDRVAsVUFBVSxLQUNUQSxVQUFVLENBQUNhLFFBQVgsSUFBdUIsS0FBS0MsSUFBTCxDQUFVZCxVQUFVLENBQUNlLGFBQXJCLENBRGQsQ0FEWixFQUlFO0FBRUYsUUFBSUMsS0FBSyxDQUFDVCxVQUFELENBQVQsRUFBdUIsT0FYVCxDQWFkO0FBQ0E7QUFDQTs7QUFDQSxRQUFJVSxpQkFBaUIsR0FBRyxDQUF4QjtBQUNBLFFBQUlDLHFCQUFxQixHQUFHLENBQTVCOztBQUNBLFVBQU1DLGdCQUFnQixHQUFJQyxRQUFELElBQTRCO0FBQ25ELFVBQUlILGlCQUFpQixHQUFHVixVQUF4QixFQUFvQyxPQUFPYyxRQUFRLENBQUM7QUFBRUMsUUFBQUEsSUFBSSxFQUFFO0FBQVIsT0FBRCxDQUFmO0FBRXBDLFlBQU1DLGFBQWEsR0FBR0gsUUFBUSxDQUFDRyxhQUFULEVBQXRCLENBSG1ELENBSW5EO0FBQ0E7O0FBQ0EsVUFBSUwscUJBQXFCLEdBQUcsRUFBeEIsSUFBOEJLLGFBQWEsR0FBRyxFQUFsRCxFQUNFTixpQkFBaUIsSUFBSU0sYUFBckI7QUFFRkwsTUFBQUEscUJBQXFCLEdBQUdLLGFBQXhCO0FBQ0F6QixNQUFBQSxtQkFBbUIsU0FBbkIsSUFBQUEsbUJBQW1CLFdBQW5CLFlBQUFBLG1CQUFtQixDQUFHcUIsZ0JBQUgsQ0FBbkI7QUFDRCxLQVhEOztBQWFBLFFBQUlyQixtQkFBSixFQUF5QjtBQUN2QkEsTUFBQUEsbUJBQW1CLENBQUNxQixnQkFBRCxDQUFuQjtBQUNELEtBRkQsTUFFTztBQUNMSyxNQUFBQSxVQUFVLENBQUMsTUFBTUgsUUFBUSxDQUFDO0FBQUVDLFFBQUFBLElBQUksRUFBRTtBQUFSLE9BQUQsQ0FBZixFQUFrQ2YsVUFBbEMsQ0FBVjtBQUNEO0FBQ0YsR0FwQ0QsRUFvQ0csRUFwQ0g7QUFzQ0EsUUFBTWtCLFlBQVksR0FBR0MsU0FBUyxDQUFDckIsUUFBRCxDQUE5QjtBQUVBLFFBQU1nQixRQUFRLEdBQUcsd0JBQ2YsQ0FBQztBQUFFQyxJQUFBQSxJQUFJLEdBQUc7QUFBVCxHQUFELEtBQXFCO0FBQ25CLFFBQUksQ0FBQ2hCLFdBQUwsRUFBa0I7QUFDaEI7QUFDQXFCLE1BQUFBLE9BQU8sQ0FBQ0MsS0FBUixDQUFjLDRDQUFkO0FBQ0E7QUFDRDs7QUFFRCxRQUFJLENBQUN2QixRQUFMLEVBQWU7QUFDYjtBQUNBc0IsTUFBQUEsT0FBTyxDQUFDQyxLQUFSLENBQWMsNkNBQWQ7QUFDQTtBQUNEOztBQUVELFFBQUlwQixLQUFLLEtBQUssU0FBZCxFQUF5QjtBQUN6QixRQUFJQSxLQUFLLEtBQUssTUFBZCxFQUFzQixPQUFPaUIsWUFBWSxDQUFDSSxLQUFiLEVBQVA7QUFDdEIsUUFBSXJCLEtBQUssS0FBSyxVQUFkLEVBQTBCLE9BQU9pQixZQUFZLENBQUNILElBQWIsRUFBUDs7QUFFMUIsUUFBSSxDQUFDcEIsWUFBTCxFQUFtQjtBQUNqQkEsTUFBQUEsWUFBWSxHQUFHLElBQWY7QUFDQXVCLE1BQUFBLFlBQVksQ0FBQ0ssSUFBYixDQUFrQjtBQUFFeEIsUUFBQUEsV0FBRjtBQUFlRyxRQUFBQSxRQUFmO0FBQXlCQyxRQUFBQSxLQUF6QjtBQUFnQ0MsUUFBQUE7QUFBaEMsT0FBbEI7QUFDRDs7QUFFRCxRQUFJVyxJQUFKLEVBQVU7QUFDUmIsTUFBQUEsUUFBUSxDQUFDLFNBQUQsQ0FBUjtBQUNBZ0IsTUFBQUEsWUFBWSxDQUFDSCxJQUFiO0FBQ0FiLE1BQUFBLFFBQVEsQ0FBQyxNQUFELENBQVI7QUFDRDtBQUNGLEdBNUJjLEVBNkJmLEVBN0JlLENBQWpCO0FBZ0NBLFNBQU8sQ0FBQ0QsS0FBRCxFQUFRYSxRQUFSLENBQVA7QUFDRCxDQTFGRDs7ZUE0RmVsQixPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICd0eXBlcydcbmltcG9ydCB7IExpdmVDaGF0TG9hZGVyQ29udGV4dCB9IGZyb20gJ2NvbnRleHQnXG5pbXBvcnQgKiBhcyBQcm92aWRlcnMgZnJvbSAncHJvdmlkZXJzJ1xuXG5jb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayA6IG51bGxcbmNvbnN0IGNvbm5lY3Rpb24gPVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgIHdpbmRvdy5uYXZpZ2F0b3IgJiYgKHdpbmRvdy5uYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uXG4gICAgOiBudWxsXG5cbmxldCBzY3JpcHRMb2FkZWQgPSBmYWxzZVxuXG5jb25zdCB1c2VDaGF0ID0gKFxuICB7XG4gICAgbG9hZFdoZW5JZGxlXG4gIH06IHtcbiAgICBsb2FkV2hlbklkbGU6IGJvb2xlYW5cbiAgfSA9IHsgbG9hZFdoZW5JZGxlOiBmYWxzZSB9XG4pOiBbU3RhdGUsICh7IG9wZW4gfTogeyBvcGVuOiBib29sZWFuIH0pID0+IHZvaWRdID0+IHtcbiAgY29uc3Qge1xuICAgIHByb3ZpZGVyLFxuICAgIHByb3ZpZGVyS2V5LFxuICAgIGlkbGVQZXJpb2QsXG4gICAgc3RhdGUsXG4gICAgc2V0U3RhdGUsXG4gICAgYXBwSUQsXG4gICAgbG9jYWxlXG4gIH0gPSB1c2VDb250ZXh0KExpdmVDaGF0TG9hZGVyQ29udGV4dClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIERvbid0IGxvYWQgaWYgaWRsZVBlcmlvZCBpcyAwLCBudWxsIG9yIHVuZGVmaW5lZFxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhbG9hZFdoZW5JZGxlIHx8ICFpZGxlUGVyaW9kKSByZXR1cm5cblxuICAgIC8vIERvbid0IGxvYWQgaWYgMmcgY29ubmVjdGlvbiBvciBzYXZlLWRhdGEgaXMgZW5hYmxlZFxuICAgIGlmIChcbiAgICAgIGNvbm5lY3Rpb24gJiZcbiAgICAgIChjb25uZWN0aW9uLnNhdmVEYXRhIHx8IC8yZy8udGVzdChjb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGUpKVxuICAgIClcbiAgICAgIHJldHVyblxuXG4gICAgaWYgKGlzTmFOKGlkbGVQZXJpb2QpKSByZXR1cm5cblxuICAgIC8vIGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSBoYXMgYW4gdXBwZXIgbGltaXQgb2YgNTAgbWlsbGlzZWNvbmRzXG4gICAgLy8gV2Ugd2FudCB0byBlbnN1cmUgdGhlIHBhZ2UgaGFzIGJlZW4gaWRsZSBmb3IgYSBzaWduaWZpY2FudCBwZXJpb2Qgb2YgdGltZVxuICAgIC8vIFRoZXJlZm9yZSB3ZSBjb3VudCBjb25zZWN1dGl2ZSBtYXhpbXVtIHRpbWVSZW1haW5pbmcgY291bnRzIGFuZCBsb2FkIGNoYXQgd2hlbiB3ZSByZWFjaCBvdXIgdGhyZXNob2xkXG4gICAgbGV0IGVsYXBzZWRJZGxlUGVyaW9kID0gMFxuICAgIGxldCBwcmV2aW91c1RpbWVSZW1haW5pbmcgPSAwXG4gICAgY29uc3Qgc2NoZWR1bGVMb2FkQ2hhdCA9IChkZWFkbGluZTogSWRsZURlYWRsaW5lKSA9PiB7XG4gICAgICBpZiAoZWxhcHNlZElkbGVQZXJpb2QgPiBpZGxlUGVyaW9kKSByZXR1cm4gbG9hZENoYXQoeyBvcGVuOiBmYWxzZSB9KVxuXG4gICAgICBjb25zdCB0aW1lUmVtYWluaW5nID0gZGVhZGxpbmUudGltZVJlbWFpbmluZygpXG4gICAgICAvLyBUbyBlbnN1cmUgYnJvd3NlciBpcyBpZGxlLCBvbmx5IGFjY3VtYWx0ZSBlbGFwc2VkSWRsZVBlcmlvZCB3aGVuXG4gICAgICAvLyB0d28gY29uc2VjdXRpdmUgbWF4aW11bSB0aW1lUmVtYWluaW5nJ3MgaGF2ZSBiZWVuIG9ic2VydmVkXG4gICAgICBpZiAocHJldmlvdXNUaW1lUmVtYWluaW5nID4gNDkgJiYgdGltZVJlbWFpbmluZyA+IDQ5KVxuICAgICAgICBlbGFwc2VkSWRsZVBlcmlvZCArPSB0aW1lUmVtYWluaW5nXG5cbiAgICAgIHByZXZpb3VzVGltZVJlbWFpbmluZyA9IHRpbWVSZW1haW5pbmdcbiAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2s/LihzY2hlZHVsZUxvYWRDaGF0KVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0SWRsZUNhbGxiYWNrKSB7XG4gICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKHNjaGVkdWxlTG9hZENoYXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gbG9hZENoYXQoeyBvcGVuOiBmYWxzZSB9KSwgaWRsZVBlcmlvZClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IGNoYXRQcm92aWRlciA9IFByb3ZpZGVyc1twcm92aWRlcl1cblxuICBjb25zdCBsb2FkQ2hhdCA9IHVzZUNhbGxiYWNrPChhcmdzOiB7IG9wZW46IGJvb2xlYW4gfSkgPT4gdm9pZD4oXG4gICAgKHsgb3BlbiA9IHRydWUgfSkgPT4ge1xuICAgICAgaWYgKCFwcm92aWRlcktleSkge1xuICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGFwaSBrZXkgZ2l2ZW4gdG8gcmVhY3QtbGl2ZS1jaGF0LWxvYWRlcicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvcignTm8gcHJvdmlkZXIgZ2l2ZW4gdG8gcmVhY3QtbGl2ZS1jaGF0LWxvYWRlcicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09ICdvcGVuaW5nJykgcmV0dXJuXG4gICAgICBpZiAoc3RhdGUgPT09ICdvcGVuJykgcmV0dXJuIGNoYXRQcm92aWRlci5jbG9zZSgpXG4gICAgICBpZiAoc3RhdGUgPT09ICdjb21wbGV0ZScpIHJldHVybiBjaGF0UHJvdmlkZXIub3BlbigpXG5cbiAgICAgIGlmICghc2NyaXB0TG9hZGVkKSB7XG4gICAgICAgIHNjcmlwdExvYWRlZCA9IHRydWVcbiAgICAgICAgY2hhdFByb3ZpZGVyLmxvYWQoeyBwcm92aWRlcktleSwgc2V0U3RhdGUsIGFwcElELCBsb2NhbGUgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgc2V0U3RhdGUoJ29wZW5pbmcnKVxuICAgICAgICBjaGF0UHJvdmlkZXIub3BlbigpXG4gICAgICAgIHNldFN0YXRlKCdvcGVuJylcbiAgICAgIH1cbiAgICB9LFxuICAgIFtdXG4gIClcblxuICByZXR1cm4gW3N0YXRlLCBsb2FkQ2hhdF1cbn1cblxuZXhwb3J0IGRlZmF1bHQgdXNlQ2hhdFxuIl19